#!/usr/bin/env python3
"""
GPAW wrapper for real-space grid DFT calculations with Python
"""
from pathlib import Path
from typing import Dict, Any, List, Optional
import subprocess
import re
import json
from .base_wrapper import SimulationWrapper


class GPAWWrapper(SimulationWrapper):
    """Wrapper for GPAW Python-based DFT package"""

    def _detect_app_path(self) -> Path:
        """Detect GPAW installation path"""
        # GPAW is typically installed via pip, so check Python installation
        try:
            result = subprocess.run(
                ['python3', '-c', 'import gpaw; print(gpaw.__file__)'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                gpaw_file = result.stdout.strip()
                return Path(gpaw_file).parent
        except:
            pass

        # Check APPS directory
        apps_path = Path(__file__).parent.parent / "APPS" / "gpaw"
        return apps_path

    def _validate_installation(self) -> bool:
        """Validate that GPAW is properly installed"""
        try:
            result = subprocess.run(
                ['python3', '-c', 'import gpaw; print(gpaw.__version__)'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                self.version = result.stdout.strip()
                return True
        except:
            pass

        # Try gpaw command
        try:
            result = subprocess.run(['gpaw', 'info'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                version_match = re.search(r'version:\s+(\S+)', result.stdout)
                if version_match:
                    self.version = version_match.group(1)
                else:
                    self.version = "unknown"
                return True
        except:
            pass

        self.version = "not_installed"
        return False

    def _generate_input_file(self, job_params: Dict[str, Any], input_file: Path) -> None:
        """
        Generate GPAW Python script

        Expected job_params:
        - calculation_type: 'energy', 'relaxation', 'md' (default: 'energy')
        - system_name: Name for the calculation (default: 'GPAW_calc')
        - atomic_structure: Dict with 'atoms' and 'cell' or 'molecule_smiles'
        - mode: 'fd' (finite difference), 'pw' (plane wave), 'lcao' (default: 'fd')
        - xc: Exchange-correlation functional (default: 'PBE')
        - h: Grid spacing in Angstrom (default: 0.2)
        - nbands: Number of bands (default: auto)
        """
        calc_type = job_params.get('calculation_type', 'energy')
        system_name = job_params.get('system_name', 'GPAW_calc')
        mode = job_params.get('mode', 'fd')
        xc = job_params.get('xc', 'PBE')
        h = job_params.get('h', 0.2)

        # Get atomic structure (priority: atomic_structure > xyz_structure > molecule_smiles > default)
        if 'atomic_structure' in job_params:
            structure = job_params['atomic_structure']
        elif 'cif_structure' in job_params:
            # Parse CIF format string
            structure = self._parse_cif(job_params['cif_structure'])
        elif 'xyz_structure' in job_params:
            structure = self._parse_xyz(job_params['xyz_structure'])
        elif 'molecule_smiles' in job_params:
            structure = self._smiles_to_structure(job_params['molecule_smiles'])
        else:
            structure = self._default_structure()

        atoms = structure['atoms']
        cell = structure.get('cell', [[20.0, 0, 0], [0, 20.0, 0], [0, 0, 20.0]])

        # Generate Python script
        script_content = f"""#!/usr/bin/env python3
\"\"\"
GPAW calculation script for {system_name}
Generated by Backplane GPAW wrapper
\"\"\"
from ase import Atoms
from gpaw import GPAW, PW, FermiDirac
from ase.optimize import QuasiNewton
from ase.io import write
import json

# Define atomic structure
atoms = Atoms(
    symbols=[{', '.join(f"'{atom['element']}'" for atom in atoms)}],
    positions=[
"""

        for atom in atoms:
            script_content += f"        [{atom['x']:.8f}, {atom['y']:.8f}, {atom['z']:.8f}],\n"

        script_content += f"""    ],
    cell=[
        [{cell[0][0]:.6f}, {cell[0][1]:.6f}, {cell[0][2]:.6f}],
        [{cell[1][0]:.6f}, {cell[1][1]:.6f}, {cell[1][2]:.6f}],
        [{cell[2][0]:.6f}, {cell[2][1]:.6f}, {cell[2][2]:.6f}]
    ],
    pbc=False  # No periodic boundary conditions (molecule in box)
)

# Center the molecule in the cell
atoms.center()

# Set up GPAW calculator
calc = GPAW(
    mode='{mode}',  # Calculation mode
    h={h},  # Grid spacing in Angstrom
    xc='{xc}',  # Exchange-correlation functional
    txt='gpaw_output.txt',  # Output file
    occupations=FermiDirac(0.1),  # Fermi-Dirac smearing
    convergence={{'energy': 1e-4}}  # Energy convergence criterion
)

atoms.calc = calc

# Perform calculation
results = {{}}
results['system_name'] = '{system_name}'
results['calculation_type'] = '{calc_type}'

"""

        if calc_type == 'relaxation':
            script_content += """
# Optimize geometry
opt = QuasiNewton(atoms, trajectory='optimization.traj')
opt.run(fmax=0.05)  # Optimize until forces < 0.05 eV/Ang

results['optimized'] = True
results['optimization_steps'] = opt.get_number_of_steps()
"""
        else:
            script_content += """
# Calculate energy
energy = atoms.get_potential_energy()
results['optimized'] = False
"""

        script_content += """
# Get final results
results['energy_ev'] = atoms.get_potential_energy()
results['energy_hartree'] = results['energy_ev'] / 27.2114
results['forces'] = atoms.get_forces().tolist()
results['positions'] = atoms.get_positions().tolist()

# Get additional properties
try:
    results['dipole_moment'] = calc.get_dipole_moment().tolist()
except:
    pass

# Save results to JSON
with open('gpaw_results.json', 'w') as f:
    json.dump(results, f, indent=2)

# Save final structure
write('final_structure.xyz', atoms)

print("\\nCalculation completed successfully!")
print(f"Final energy: {results['energy_ev']:.4f} eV")
"""

        # Write script
        with open(input_file, 'w') as f:
            f.write(script_content)

        # Make executable
        input_file.chmod(0o755)

    def _parse_xyz(self, xyz_string: str) -> Dict[str, Any]:
        """
        Parse XYZ format string into atomic structure dict

        XYZ format:
        <number of atoms>
        <comment line>
        <element> <x> <y> <z>
        <element> <x> <y> <z>
        ...
        """
        lines = xyz_string.strip().split('\n')

        if len(lines) < 3:
            raise ValueError("Invalid XYZ format: need at least 3 lines (n_atoms, comment, coordinates)")

        try:
            n_atoms = int(lines[0].strip())
        except ValueError:
            raise ValueError(f"Invalid XYZ format: first line must be number of atoms, got '{lines[0]}'")

        # Comment line is lines[1], skip it

        atoms = []
        for i, line in enumerate(lines[2:], start=2):
            if not line.strip():
                continue

            parts = line.split()
            if len(parts) < 4:
                continue

            try:
                element = parts[0]
                x = float(parts[1])
                y = float(parts[2])
                z = float(parts[3])

                atoms.append({
                    'element': element,
                    'x': x,
                    'y': y,
                    'z': z
                })
            except (ValueError, IndexError) as e:
                raise ValueError(f"Invalid XYZ format at line {i+1}: {line.strip()}")

        if len(atoms) != n_atoms:
            print(f"Warning: XYZ file claims {n_atoms} atoms but found {len(atoms)} coordinate lines")

        if not atoms:
            raise ValueError("No atoms found in XYZ structure")

        print(f"Successfully parsed XYZ structure with {len(atoms)} atoms")
        return {'atoms': atoms}

    def _parse_cif(self, cif_string: str) -> Dict[str, Any]:
        """
        Parse CIF format string into atomic structure dict.
        Uses the CIF parser module.
        """
        import sys
        sys.path.insert(0, str(Path(__file__).parent.parent))
        from cif_parser import create_cif_parser

        parser = create_cif_parser()
        structure = parser.parse_cif(cif_string)

        # Return in the format expected by the wrapper
        return {
            'atoms': structure['atoms'],
            'cell': structure['cell_matrix']
        }


    def _smiles_to_structure(self, smiles: str) -> Dict[str, Any]:
        """Convert SMILES to atomic structure using RDKit"""
        try:
            from rdkit import Chem
            from rdkit.Chem import AllChem

            # Parse SMILES
            mol = Chem.MolFromSmiles(smiles)
            if mol is None:
                raise ValueError(f"Invalid SMILES: {smiles}")

            # Add explicit hydrogens
            mol = Chem.AddHs(mol)

            # Generate 3D coordinates
            # Use ETKDG method (Experimental Torsion-angle Knowledge Distance Geometry)
            AllChem.EmbedMolecule(mol, randomSeed=42, useRandomCoords=False)

            # Optimize geometry with UFF force field
            try:
                AllChem.UFFOptimizeMolecule(mol, maxIters=200)
            except:
                # If UFF fails, try MMFF
                try:
                    AllChem.MMFFOptimizeMolecule(mol, maxIters=200)
                except:
                    pass  # Use unoptimized geometry

            # Extract atomic structure
            conf = mol.GetConformer()
            atoms = []
            for atom in mol.GetAtoms():
                pos = conf.GetAtomPosition(atom.GetIdx())
                atoms.append({
                    'element': atom.GetSymbol(),
                    'x': pos.x,
                    'y': pos.y,
                    'z': pos.z
                })

            print(f"Successfully converted SMILES '{smiles}' to 3D structure with {len(atoms)} atoms")
            return {'atoms': atoms}

        except Exception as e:
            print(f"Warning: SMILES conversion failed for '{smiles}': {e}")
            print(f"Falling back to default structure (H2O)")
            return self._default_structure()

    def _default_structure(self) -> Dict[str, Any]:
        """Default structure: water molecule"""
        return {
            'atoms': [
                {'element': 'O', 'x': 0.0, 'y': 0.0, 'z': 0.0},
                {'element': 'H', 'x': 0.76, 'y': 0.59, 'z': 0.0},
                {'element': 'H', 'x': -0.76, 'y': 0.59, 'z': 0.0},
            ]
        }

    def _parse_output_file(self, output_file: Path, job_dir: Path) -> Dict[str, Any]:
        """
        Parse GPAW output (JSON results file)

        GPAW generates a JSON file with results
        """
        # Check for JSON results file
        json_file = job_dir / "gpaw_results.json"
        if json_file.exists():
            with open(json_file, 'r') as f:
                results = json.load(f)
            return results

        # Fall back to parsing text output
        if not output_file.exists():
            return {"error": "Output file not found"}

        with open(output_file, 'r') as f:
            content = f.read()

        results = {}

        # Try to extract energy from text output
        energy_pattern = r'Final energy:\s+([-\d.]+)\s+eV'
        energy_match = re.search(energy_pattern, content)
        if energy_match:
            energy_ev = float(energy_match.group(1))
            results['energy_ev'] = energy_ev
            results['energy_hartree'] = energy_ev / 27.2114

        # Check for convergence
        if 'Calculation completed successfully' in content:
            results['converged'] = True
        else:
            results['converged'] = False

        return results

    def _get_run_command(self, input_file: Path, output_file: Path, job_dir: Path) -> List[str]:
        """Get command to run GPAW script"""
        return ['python3', input_file.name]

    def _get_input_filename(self) -> str:
        return "gpaw_calc.py"

    def _get_output_filename(self) -> str:
        return "gpaw_output.txt"
