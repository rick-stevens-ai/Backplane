#!/usr/bin/env python3
"""
LAMMPS wrapper for classical molecular dynamics with ReaxFF
"""
from pathlib import Path
from typing import Dict, Any, List, Optional
import subprocess
import re
from .base_wrapper import SimulationWrapper


class LAMMPSWrapper(SimulationWrapper):
    """Wrapper for LAMMPS molecular dynamics package"""

    def _detect_app_path(self) -> Path:
        """Detect LAMMPS installation path"""
        # Check in APPS directory first
        apps_path = Path(__file__).parent.parent / "APPS" / "lammps"
        if apps_path.exists():
            return apps_path

        # Check if lmp is in PATH
        try:
            result = subprocess.run(['which', 'lmp'], capture_output=True, text=True)
            if result.returncode == 0:
                return Path(result.stdout.strip()).parent.parent
        except:
            pass

        return apps_path

    def _validate_installation(self) -> bool:
        """Validate that LAMMPS executable exists"""
        lmp = self._find_executable()
        if lmp and lmp.exists():
            try:
                result = subprocess.run([str(lmp), '-help'], capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    version_match = re.search(r'LAMMPS \((.*?)\)', result.stdout)
                    if version_match:
                        self.version = version_match.group(1)
                    else:
                        self.version = "unknown"
                    return True
            except:
                pass

        self.version = "not_installed"
        return False

    def _find_executable(self) -> Optional[Path]:
        """Find LAMMPS executable"""
        for exe_name in ['lmp', 'lammps', 'lmp_serial']:
            # Check in bin directory
            bin_path = self.app_path / "bin" / exe_name
            if bin_path.exists():
                return bin_path

            # Check system PATH
            try:
                result = subprocess.run(['which', exe_name], capture_output=True, text=True)
                if result.returncode == 0:
                    return Path(result.stdout.strip())
            except:
                pass

        return None

    def _generate_input_file(self, job_params: Dict[str, Any], input_file: Path) -> None:
        """
        Generate LAMMPS input script

        Expected job_params:
        - simulation_type: 'energy', 'minimize', 'md', 'reaxff' (default: 'minimize')
        - system_name: Name for the calculation (default: 'LAMMPS_sim')
        - atomic_structure: Dict with 'atoms' and 'cell' or 'molecule_smiles'
        - force_field: 'lj', 'reaxff', 'eam', etc. (default: 'lj')
        - temperature: Temperature in K (default: 300)
        - timestep: Timestep in fs (default: 1.0)
        - steps: Number of MD steps (default: 1000)
        """
        sim_type = job_params.get('simulation_type', 'minimize')
        system_name = job_params.get('system_name', 'LAMMPS_sim')
        force_field = job_params.get('force_field', 'lj')
        temperature = job_params.get('temperature', 300.0)
        timestep = job_params.get('timestep', 1.0)
        steps = job_params.get('steps', 1000)

        # Get atomic structure - supports atomic_structure dict, XYZ, or SMILES
        if 'atomic_structure' in job_params:
            structure = job_params['atomic_structure']
        elif 'cif_structure' in job_params:
            # Parse CIF format string
            structure = self._parse_cif(job_params['cif_structure'])
        elif 'xyz_structure' in job_params:
            # Parse XYZ format string
            structure = self._parse_xyz(job_params['xyz_structure'])
        elif 'molecule_smiles' in job_params:
            structure = self._smiles_to_structure(job_params['molecule_smiles'])
        else:
            structure = self._default_structure()

        atoms = structure['atoms']
        cell = structure.get('cell', [[20.0, 0, 0], [0, 20.0, 0], [0, 0, 20.0]])

        # Store structure for bond access
        self._current_structure = structure

        # Generate data file first
        data_file = input_file.parent / "data.lammps"
        self._generate_data_file(atoms, cell, data_file)

        # Build input script
        input_content = f"""# LAMMPS input script for {system_name}
# Generated by Backplane LAMMPS wrapper

# Initialization
units           real
atom_style      full
boundary        p p p

# Read structure
read_data       data.lammps

# Define force field
"""

        # Check if we have bonds
        has_bonds = 'bonds' in structure and len(structure.get('bonds', [])) > 0

        if force_field == 'lj':
            input_content += """# Lennard-Jones potential
pair_style      lj/cut 10.0
"""
            if has_bonds:
                input_content += """bond_style      harmonic
"""
        elif force_field == 'reaxff':
            input_content += """# ReaxFF reactive force field
pair_style      reaxff NULL
pair_coeff      * * ffield.reax C H O
fix             qeq all qeq/reax 1 0.0 10.0 1.0e-6 reaxff
"""

        input_content += f"""
# Output settings
thermo          100
thermo_style    custom step temp pe ke etotal press vol

# Dump trajectory
dump            1 all custom 100 trajectory.lammpstrj id type x y z fx fy fz

"""

        if sim_type == 'minimize':
            input_content += """# Energy minimization
minimize        1.0e-4 1.0e-6 1000 10000

# Output final energy
variable        final_energy equal pe
print           "Final Energy: ${final_energy} kcal/mol"
"""

        elif sim_type == 'md' or sim_type == 'reaxff':
            input_content += f"""# Molecular dynamics
timestep        {timestep}

# Initial velocities
velocity        all create {temperature} 12345

# NVT ensemble
fix             1 all nvt temp {temperature} {temperature} 100.0

# Run MD
run             {steps}

# Output final energy
variable        final_energy equal pe
variable        final_temp equal temp
print           "Final Energy: ${{final_energy}} kcal/mol"
print           "Final Temperature: ${{final_temp}} K"
"""

        else:  # energy calculation
            input_content += """# Single point energy
run             0

variable        energy equal pe
print           "Energy: ${energy} kcal/mol"
"""

        # Write input file
        with open(input_file, 'w') as f:
            f.write(input_content)

    def _generate_data_file(self, atoms: List[Dict], cell: List[List[float]], data_file: Path) -> None:
        """Generate LAMMPS data file"""
        nat = len(atoms)
        unique_elements = sorted(set(atom['element'] for atom in atoms))
        ntyp = len(unique_elements)
        element_to_type = {elem: i+1 for i, elem in enumerate(unique_elements)}

        # Get bonds from structure
        bonds = []
        if isinstance(atoms, list) and len(atoms) > 0 and hasattr(self, '_current_structure'):
            bonds = self._current_structure.get('bonds', [])

        # Write data file
        content = f"""LAMMPS data file - Generated by Backplane

{nat} atoms
{ntyp} atom types
{len(bonds)} bonds
{1 if bonds else 0} bond types

0.0 {cell[0][0]:.6f} xlo xhi
0.0 {cell[1][1]:.6f} ylo yhi
0.0 {cell[2][2]:.6f} zlo zhi

Masses

"""

        for i, elem in enumerate(unique_elements):
            mass = self._get_atomic_mass(elem)
            content += f"{i+1} {mass}\n"

        # Add pair coefficients for better LJ parameters
        content += "\nPair Coeffs\n\n"
        lj_params = {
            'C': (0.105, 3.431),  # epsilon (kcal/mol), sigma (Angstrom)
            'H': (0.030, 2.500),
            'N': (0.069, 3.660),
            'O': (0.140, 3.118),
        }
        for i, elem in enumerate(unique_elements):
            epsilon, sigma = lj_params.get(elem, (0.1, 3.0))
            content += f"{i+1} {epsilon} {sigma}\n"

        content += "\nAtoms\n\n"

        for i, atom in enumerate(atoms):
            atom_type = element_to_type[atom['element']]
            charge = atom.get('charge', 0.0)
            content += f"{i+1} 1 {atom_type} {charge:.6f} {atom['x']:.6f} {atom['y']:.6f} {atom['z']:.6f}\n"

        # Add bonds if present
        if bonds:
            content += "\nBond Coeffs\n\n"
            content += "1 300.0 1.5\n"  # Generic bond: k=300 kcal/mol/A^2, r0=1.5 A

            content += "\nBonds\n\n"
            for i, bond in enumerate(bonds):
                content += f"{i+1} 1 {bond['atom1']+1} {bond['atom2']+1}\n"

        with open(data_file, 'w') as f:
            f.write(content)

    def _smiles_to_structure(self, smiles: str) -> Dict[str, Any]:
        """Convert SMILES to atomic structure using RDKit"""
        try:
            from rdkit import Chem
            from rdkit.Chem import AllChem

            # Create molecule from SMILES
            mol = Chem.MolFromSmiles(smiles)
            if mol is None:
                return self._default_structure()

            # Add hydrogens
            mol = Chem.AddHs(mol)

            # Generate 3D coordinates
            AllChem.EmbedMolecule(mol, randomSeed=42)
            AllChem.MMFFOptimizeMolecule(mol)

            # Get conformer
            conf = mol.GetConformer()

            # Extract atoms and positions
            atoms = []
            bonds = []

            # Center molecule at (10, 10, 10)
            offset_x, offset_y, offset_z = 10.0, 10.0, 10.0

            for atom in mol.GetAtoms():
                pos = conf.GetAtomPosition(atom.GetIdx())
                atoms.append({
                    'element': atom.GetSymbol(),
                    'x': pos.x + offset_x,
                    'y': pos.y + offset_y,
                    'z': pos.z + offset_z,
                    'charge': 0.0  # Will be computed by force field if needed
                })

            # Extract bonds
            for bond in mol.GetBonds():
                bonds.append({
                    'atom1': bond.GetBeginAtomIdx(),
                    'atom2': bond.GetEndAtomIdx(),
                    'type': int(bond.GetBondTypeAsDouble())
                })

            # Determine box size (molecule extent + 10 Ã… padding)
            coords = [(a['x'], a['y'], a['z']) for a in atoms]
            max_x = max(c[0] for c in coords) + 5.0
            max_y = max(c[1] for c in coords) + 5.0
            max_z = max(c[2] for c in coords) + 5.0
            min_x = min(c[0] for c in coords) - 5.0
            min_y = min(c[1] for c in coords) - 5.0
            min_z = min(c[2] for c in coords) - 5.0

            box_size = max(max_x - min_x, max_y - min_y, max_z - min_z, 20.0)

            return {
                'atoms': atoms,
                'bonds': bonds,
                'cell': [[box_size, 0, 0], [0, box_size, 0], [0, 0, box_size]]
            }

        except ImportError:
            # RDKit not available, use default
            return self._default_structure()
        except Exception as e:
            print(f"Error converting SMILES: {e}")
            return self._default_structure()

    def _parse_xyz(self, xyz_string: str) -> Dict[str, Any]:
        """
        Parse XYZ format string into atomic structure dict.

        XYZ format:
        <number of atoms>
        <comment line>
        <element> <x> <y> <z>
        ...
        """
        lines = xyz_string.strip().split('\n')

        if len(lines) < 3:
            raise ValueError("Invalid XYZ format: need at least 3 lines")

        try:
            n_atoms = int(lines[0].strip())
        except ValueError:
            raise ValueError(f"Invalid XYZ format: first line must be number of atoms")

        atoms = []
        for i, line in enumerate(lines[2:], start=2):
            if not line.strip():
                continue

            parts = line.split()
            if len(parts) < 4:
                continue

            try:
                element = parts[0]
                x = float(parts[1])
                y = float(parts[2])
                z = float(parts[3])

                atoms.append({
                    'element': element,
                    'x': x,
                    'y': y,
                    'z': z,
                    'charge': 0.0
                })
            except (ValueError, IndexError) as e:
                raise ValueError(f"Invalid XYZ format at line {i+1}: {line.strip()}")

        # Determine box size based on molecule extent
        if atoms:
            coords = [(a['x'], a['y'], a['z']) for a in atoms]
            max_x = max(c[0] for c in coords) + 10.0
            max_y = max(c[1] for c in coords) + 10.0
            max_z = max(c[2] for c in coords) + 10.0
            min_x = min(c[0] for c in coords) - 10.0
            min_y = min(c[1] for c in coords) - 10.0
            min_z = min(c[2] for c in coords) - 10.0

            box_x = max(max_x - min_x, 20.0)
            box_y = max(max_y - min_y, 20.0)
            box_z = max(max_z - min_z, 20.0)

            return {
                'atoms': atoms,
                'cell': [[box_x, 0, 0], [0, box_y, 0], [0, 0, box_z]]
            }

        return {'atoms': atoms}

    def _parse_cif(self, cif_string: str) -> Dict[str, Any]:
        """
        Parse CIF format string into atomic structure dict.
        Uses the CIF parser module.
        """
        import sys
        sys.path.insert(0, str(Path(__file__).parent.parent))
        from cif_parser import create_cif_parser

        parser = create_cif_parser()
        structure = parser.parse_cif(cif_string)

        # Return in the format expected by the wrapper
        return {
            'atoms': structure['atoms'],
            'cell': structure['cell_matrix']
        }


    def _default_structure(self) -> Dict[str, Any]:
        """Default structure: water molecule"""
        return {
            'atoms': [
                {'element': 'O', 'x': 10.0, 'y': 10.0, 'z': 10.0},
                {'element': 'H', 'x': 10.76, 'y': 10.59, 'z': 10.0},
                {'element': 'H', 'x': 9.24, 'y': 10.59, 'z': 10.0},
            ]
        }

    def _get_atomic_mass(self, element: str) -> float:
        """Get atomic mass for element"""
        masses = {
            'H': 1.008, 'C': 12.011, 'N': 14.007, 'O': 15.999,
            'F': 18.998, 'P': 30.974, 'S': 32.065, 'Cl': 35.453,
            'Fe': 55.845, 'Cu': 63.546, 'Pt': 195.084, 'Ru': 101.07,
            'Mo': 95.95, 'Co': 58.933, 'Ni': 58.693, 'Re': 186.207,
            'W': 183.84, 'Ir': 192.217, 'Os': 190.23, 'Ti': 47.867,
            'V': 50.942, 'Mn': 54.938, 'Pd': 106.42
        }
        return masses.get(element, 1.0)

    def _parse_output_file(self, output_file: Path, job_dir: Path) -> Dict[str, Any]:
        """
        Parse LAMMPS output (log.lammps)

        Extracts:
        - Final energy
        - Temperature
        - Pressure
        - Volume
        """
        # LAMMPS typically writes to log.lammps
        log_file = job_dir / "log.lammps"
        if not log_file.exists():
            log_file = output_file

        if not log_file.exists():
            return {"error": "Log file not found"}

        with open(log_file, 'r') as f:
            content = f.read()

        results = {}

        # Extract final energy
        energy_pattern = r'Final Energy:\s+([-\d.]+)\s+kcal/mol'
        energy_match = re.search(energy_pattern, content)
        if energy_match:
            energy_kcal = float(energy_match.group(1))
            results['energy_kcal_mol'] = energy_kcal
            results['energy_ev'] = energy_kcal * 0.0433641  # Convert to eV

        # Extract final temperature
        temp_pattern = r'Final Temperature:\s+([-\d.]+)\s+K'
        temp_match = re.search(temp_pattern, content)
        if temp_match:
            results['temperature_K'] = float(temp_match.group(1))

        # Extract thermodynamic data from last output
        thermo_section = re.findall(r'Step\s+Temp\s+PotEng\s+KinEng\s+TotEng\s+Press\s+Volume.*?\n((?:\d+\s+[-\d.]+\s+[-\d.]+.*?\n)+)', content)
        if thermo_section:
            last_section = thermo_section[-1]
            lines = last_section.strip().split('\n')
            if lines:
                last_line = lines[-1].split()
                if len(last_line) >= 7:
                    results['final_step'] = int(last_line[0])
                    results['final_temp'] = float(last_line[1])
                    results['potential_energy'] = float(last_line[2])
                    results['kinetic_energy'] = float(last_line[3])
                    results['total_energy'] = float(last_line[4])
                    results['pressure'] = float(last_line[5])
                    results['volume'] = float(last_line[6])

        # Check for completion
        if 'Total wall time' in content:
            results['completed'] = True
            time_match = re.search(r'Total wall time:\s+([\d:]+)', content)
            if time_match:
                results['wall_time'] = time_match.group(1)
        else:
            results['completed'] = False

        return results

    def _get_run_command(self, input_file: Path, output_file: Path, job_dir: Path) -> List[str]:
        """Get command to run LAMMPS"""
        lmp = self._find_executable()
        if not lmp:
            raise FileNotFoundError("LAMMPS executable not found")

        return [str(lmp), '-in', input_file.name, '-log', output_file.name]

    def _get_input_filename(self) -> str:
        return "in.lammps"

    def _get_output_filename(self) -> str:
        return "log.lammps"
